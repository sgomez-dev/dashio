{
  "version": 3,
  "sources": ["../../../../../../node_modules/@firebase/app-check/dist/esm/index.esm2017.js", "../../../../../../node_modules/@angular/fire/fesm2022/angular-fire-app-check.mjs", "../../../../../../node_modules/rxfire/auth/index.esm.js", "../../../../../../node_modules/@angular/fire/fesm2022/angular-fire-auth.mjs"],
  "sourcesContent": ["import { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { Deferred, ErrorFactory, isIndexedDBAvailable, getGlobal, base64, issuedAtTime, calculateBackoffMillis, getModularInstance } from '@firebase/util';\nimport { Logger } from '@firebase/logger';\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst APP_CHECK_STATES = new Map();\nconst DEFAULT_STATE = {\n    activated: false,\n    tokenObservers: []\n};\nconst DEBUG_STATE = {\n    initialized: false,\n    enabled: false\n};\n/**\n * Gets a reference to the state object.\n */\nfunction getStateReference(app) {\n    return APP_CHECK_STATES.get(app) || Object.assign({}, DEFAULT_STATE);\n}\n/**\n * Set once on initialization. The map should hold the same reference to the\n * same object until this entry is deleted.\n */\nfunction setInitialState(app, state) {\n    APP_CHECK_STATES.set(app, state);\n    return APP_CHECK_STATES.get(app);\n}\nfunction getDebugState() {\n    return DEBUG_STATE;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst BASE_ENDPOINT = 'https://content-firebaseappcheck.googleapis.com/v1';\nconst EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaV3Token';\nconst EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD = 'exchangeRecaptchaEnterpriseToken';\nconst EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\nconst TOKEN_REFRESH_TIME = {\n    /**\n     * The offset time before token natural expiration to run the refresh.\n     * This is currently 5 minutes.\n     */\n    OFFSET_DURATION: 5 * 60 * 1000,\n    /**\n     * This is the first retrial wait after an error. This is currently\n     * 30 seconds.\n     */\n    RETRIAL_MIN_WAIT: 30 * 1000,\n    /**\n     * This is the maximum retrial wait, currently 16 minutes.\n     */\n    RETRIAL_MAX_WAIT: 16 * 60 * 1000\n};\n/**\n * One day in millis, for certain error code backoffs.\n */\nconst ONE_DAY = 24 * 60 * 60 * 1000;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Port from auth proactiverefresh.js\n *\n */\n// TODO: move it to @firebase/util?\n// TODO: allow to config whether refresh should happen in the background\nclass Refresher {\n    constructor(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {\n        this.operation = operation;\n        this.retryPolicy = retryPolicy;\n        this.getWaitDuration = getWaitDuration;\n        this.lowerBound = lowerBound;\n        this.upperBound = upperBound;\n        this.pending = null;\n        this.nextErrorWaitInterval = lowerBound;\n        if (lowerBound > upperBound) {\n            throw new Error('Proactive refresh lower bound greater than upper bound!');\n        }\n    }\n    start() {\n        this.nextErrorWaitInterval = this.lowerBound;\n        this.process(true).catch(() => {\n            /* we don't care about the result */\n        });\n    }\n    stop() {\n        if (this.pending) {\n            this.pending.reject('cancelled');\n            this.pending = null;\n        }\n    }\n    isRunning() {\n        return !!this.pending;\n    }\n    async process(hasSucceeded) {\n        this.stop();\n        try {\n            this.pending = new Deferred();\n            this.pending.promise.catch(_e => {\n                /* ignore */\n            });\n            await sleep(this.getNextRun(hasSucceeded));\n            // Why do we resolve a promise, then immediate wait for it?\n            // We do it to make the promise chain cancellable.\n            // We can call stop() which rejects the promise before the following line execute, which makes\n            // the code jump to the catch block.\n            // TODO: unit test this\n            this.pending.resolve();\n            await this.pending.promise;\n            this.pending = new Deferred();\n            this.pending.promise.catch(_e => {\n                /* ignore */\n            });\n            await this.operation();\n            this.pending.resolve();\n            await this.pending.promise;\n            this.process(true).catch(() => {\n                /* we don't care about the result */\n            });\n        }\n        catch (error) {\n            if (this.retryPolicy(error)) {\n                this.process(false).catch(() => {\n                    /* we don't care about the result */\n                });\n            }\n            else {\n                this.stop();\n            }\n        }\n    }\n    getNextRun(hasSucceeded) {\n        if (hasSucceeded) {\n            // If last operation succeeded, reset next error wait interval and return\n            // the default wait duration.\n            this.nextErrorWaitInterval = this.lowerBound;\n            // Return typical wait duration interval after a successful operation.\n            return this.getWaitDuration();\n        }\n        else {\n            // Get next error wait interval.\n            const currentErrorWaitInterval = this.nextErrorWaitInterval;\n            // Double interval for next consecutive error.\n            this.nextErrorWaitInterval *= 2;\n            // Make sure next wait interval does not exceed the maximum upper bound.\n            if (this.nextErrorWaitInterval > this.upperBound) {\n                this.nextErrorWaitInterval = this.upperBound;\n            }\n            return currentErrorWaitInterval;\n        }\n    }\n}\nfunction sleep(ms) {\n    return new Promise(resolve => {\n        setTimeout(resolve, ms);\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst ERRORS = {\n    [\"already-initialized\" /* AppCheckError.ALREADY_INITIALIZED */]: 'You have already called initializeAppCheck() for FirebaseApp {$appName} with ' +\n        'different options. To avoid this error, call initializeAppCheck() with the ' +\n        'same options as when it was originally called. This will return the ' +\n        'already initialized instance.',\n    [\"use-before-activation\" /* AppCheckError.USE_BEFORE_ACTIVATION */]: 'App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. ' +\n        'Call initializeAppCheck() before instantiating other Firebase services.',\n    [\"fetch-network-error\" /* AppCheckError.FETCH_NETWORK_ERROR */]: 'Fetch failed to connect to a network. Check Internet connection. ' +\n        'Original error: {$originalErrorMessage}.',\n    [\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */]: 'Fetch client could not parse response.' +\n        ' Original error: {$originalErrorMessage}.',\n    [\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */]: 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\n    [\"storage-open\" /* AppCheckError.STORAGE_OPEN */]: 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\n    [\"storage-get\" /* AppCheckError.STORAGE_GET */]: 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\n    [\"storage-set\" /* AppCheckError.STORAGE_WRITE */]: 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\n    [\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */]: 'ReCAPTCHA error.',\n    [\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */]: `{$httpStatus} error. Attempts allowed again after {$time}`,\n    [\"throttled\" /* AppCheckError.THROTTLED */]: `Requests throttled due to previous {$httpStatus} error. Attempts allowed again after {$time}`\n};\nconst ERROR_FACTORY = new ErrorFactory('appCheck', 'AppCheck', ERRORS);\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getRecaptcha(isEnterprise = false) {\n    var _a;\n    if (isEnterprise) {\n        return (_a = self.grecaptcha) === null || _a === void 0 ? void 0 : _a.enterprise;\n    }\n    return self.grecaptcha;\n}\nfunction ensureActivated(app) {\n    if (!getStateReference(app).activated) {\n        throw ERROR_FACTORY.create(\"use-before-activation\" /* AppCheckError.USE_BEFORE_ACTIVATION */, {\n            appName: app.name\n        });\n    }\n}\nfunction getDurationString(durationInMillis) {\n    const totalSeconds = Math.round(durationInMillis / 1000);\n    const days = Math.floor(totalSeconds / (3600 * 24));\n    const hours = Math.floor((totalSeconds - days * 3600 * 24) / 3600);\n    const minutes = Math.floor((totalSeconds - days * 3600 * 24 - hours * 3600) / 60);\n    const seconds = totalSeconds - days * 3600 * 24 - hours * 3600 - minutes * 60;\n    let result = '';\n    if (days) {\n        result += pad(days) + 'd:';\n    }\n    if (hours) {\n        result += pad(hours) + 'h:';\n    }\n    result += pad(minutes) + 'm:' + pad(seconds) + 's';\n    return result;\n}\nfunction pad(value) {\n    if (value === 0) {\n        return '00';\n    }\n    return value >= 10 ? value.toString() : '0' + value;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function exchangeToken({ url, body }, heartbeatServiceProvider) {\n    const headers = {\n        'Content-Type': 'application/json'\n    };\n    // If heartbeat service exists, add heartbeat header string to the header.\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\n        optional: true\n    });\n    if (heartbeatService) {\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\n        if (heartbeatsHeader) {\n            headers['X-Firebase-Client'] = heartbeatsHeader;\n        }\n    }\n    const options = {\n        method: 'POST',\n        body: JSON.stringify(body),\n        headers\n    };\n    let response;\n    try {\n        response = await fetch(url, options);\n    }\n    catch (originalError) {\n        throw ERROR_FACTORY.create(\"fetch-network-error\" /* AppCheckError.FETCH_NETWORK_ERROR */, {\n            originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\n        });\n    }\n    if (response.status !== 200) {\n        throw ERROR_FACTORY.create(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */, {\n            httpStatus: response.status\n        });\n    }\n    let responseBody;\n    try {\n        // JSON parsing throws SyntaxError if the response body isn't a JSON string.\n        responseBody = await response.json();\n    }\n    catch (originalError) {\n        throw ERROR_FACTORY.create(\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */, {\n            originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\n        });\n    }\n    // Protobuf duration format.\n    // https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Duration\n    const match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\n    if (!match || !match[2] || isNaN(Number(match[1]))) {\n        throw ERROR_FACTORY.create(\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */, {\n            originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration ` +\n                `format: ${responseBody.ttl}`\n        });\n    }\n    const timeToLiveAsNumber = Number(match[1]) * 1000;\n    const now = Date.now();\n    return {\n        token: responseBody.token,\n        expireTimeMillis: now + timeToLiveAsNumber,\n        issuedAtTimeMillis: now\n    };\n}\nfunction getExchangeRecaptchaV3TokenRequest(app, reCAPTCHAToken) {\n    const { projectId, appId, apiKey } = app.options;\n    return {\n        url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,\n        body: {\n            'recaptcha_v3_token': reCAPTCHAToken\n        }\n    };\n}\nfunction getExchangeRecaptchaEnterpriseTokenRequest(app, reCAPTCHAToken) {\n    const { projectId, appId, apiKey } = app.options;\n    return {\n        url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD}?key=${apiKey}`,\n        body: {\n            'recaptcha_enterprise_token': reCAPTCHAToken\n        }\n    };\n}\nfunction getExchangeDebugTokenRequest(app, debugToken) {\n    const { projectId, appId, apiKey } = app.options;\n    return {\n        url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,\n        body: {\n            // eslint-disable-next-line\n            debug_token: debugToken\n        }\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DB_NAME = 'firebase-app-check-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-app-check-store';\nconst DEBUG_TOKEN_KEY = 'debug-token';\nlet dbPromise = null;\nfunction getDBPromise() {\n    if (dbPromise) {\n        return dbPromise;\n    }\n    dbPromise = new Promise((resolve, reject) => {\n        try {\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n            request.onsuccess = event => {\n                resolve(event.target.result);\n            };\n            request.onerror = event => {\n                var _a;\n                reject(ERROR_FACTORY.create(\"storage-open\" /* AppCheckError.STORAGE_OPEN */, {\n                    originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n                }));\n            };\n            request.onupgradeneeded = event => {\n                const db = event.target.result;\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch (event.oldVersion) {\n                    case 0:\n                        db.createObjectStore(STORE_NAME, {\n                            keyPath: 'compositeKey'\n                        });\n                }\n            };\n        }\n        catch (e) {\n            reject(ERROR_FACTORY.create(\"storage-open\" /* AppCheckError.STORAGE_OPEN */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            }));\n        }\n    });\n    return dbPromise;\n}\nfunction readTokenFromIndexedDB(app) {\n    return read(computeKey(app));\n}\nfunction writeTokenToIndexedDB(app, token) {\n    return write(computeKey(app), token);\n}\nfunction writeDebugTokenToIndexedDB(token) {\n    return write(DEBUG_TOKEN_KEY, token);\n}\nfunction readDebugTokenFromIndexedDB() {\n    return read(DEBUG_TOKEN_KEY);\n}\nasync function write(key, value) {\n    const db = await getDBPromise();\n    const transaction = db.transaction(STORE_NAME, 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.put({\n        compositeKey: key,\n        value\n    });\n    return new Promise((resolve, reject) => {\n        request.onsuccess = _event => {\n            resolve();\n        };\n        transaction.onerror = event => {\n            var _a;\n            reject(ERROR_FACTORY.create(\"storage-set\" /* AppCheckError.STORAGE_WRITE */, {\n                originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n            }));\n        };\n    });\n}\nasync function read(key) {\n    const db = await getDBPromise();\n    const transaction = db.transaction(STORE_NAME, 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.get(key);\n    return new Promise((resolve, reject) => {\n        request.onsuccess = event => {\n            const result = event.target.result;\n            if (result) {\n                resolve(result.value);\n            }\n            else {\n                resolve(undefined);\n            }\n        };\n        transaction.onerror = event => {\n            var _a;\n            reject(ERROR_FACTORY.create(\"storage-get\" /* AppCheckError.STORAGE_GET */, {\n                originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n            }));\n        };\n    });\n}\nfunction computeKey(app) {\n    return `${app.options.appId}-${app.name}`;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logger = new Logger('@firebase/app-check');\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\n */\nasync function readTokenFromStorage(app) {\n    if (isIndexedDBAvailable()) {\n        let token = undefined;\n        try {\n            token = await readTokenFromIndexedDB(app);\n        }\n        catch (e) {\n            // swallow the error and return undefined\n            logger.warn(`Failed to read token from IndexedDB. Error: ${e}`);\n        }\n        return token;\n    }\n    return undefined;\n}\n/**\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\n */\nfunction writeTokenToStorage(app, token) {\n    if (isIndexedDBAvailable()) {\n        return writeTokenToIndexedDB(app, token).catch(e => {\n            // swallow the error and resolve the promise\n            logger.warn(`Failed to write token to IndexedDB. Error: ${e}`);\n        });\n    }\n    return Promise.resolve();\n}\nasync function readOrCreateDebugTokenFromStorage() {\n    /**\n     * Theoretically race condition can happen if we read, then write in 2 separate transactions.\n     * But it won't happen here, because this function will be called exactly once.\n     */\n    let existingDebugToken = undefined;\n    try {\n        existingDebugToken = await readDebugTokenFromIndexedDB();\n    }\n    catch (_e) {\n        // failed to read from indexeddb. We assume there is no existing debug token, and generate a new one.\n    }\n    if (!existingDebugToken) {\n        // create a new debug token\n        // This function is only available in secure contexts. See https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts\n        const newToken = crypto.randomUUID();\n        // We don't need to block on writing to indexeddb\n        // In case persistence failed, a new debug token will be generated every time the page is refreshed.\n        // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\n        // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\n        // You should switch to a different browser that supports indexeddb\n        writeDebugTokenToIndexedDB(newToken).catch(e => logger.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`));\n        return newToken;\n    }\n    else {\n        return existingDebugToken;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isDebugMode() {\n    const debugState = getDebugState();\n    return debugState.enabled;\n}\nasync function getDebugToken() {\n    const state = getDebugState();\n    if (state.enabled && state.token) {\n        return state.token.promise;\n    }\n    else {\n        // should not happen!\n        throw Error(`\n            Can't get debug token in production mode.\n        `);\n    }\n}\nfunction initializeDebugMode() {\n    const globals = getGlobal();\n    const debugState = getDebugState();\n    // Set to true if this function has been called, whether or not\n    // it enabled debug mode.\n    debugState.initialized = true;\n    if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' &&\n        globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {\n        return;\n    }\n    debugState.enabled = true;\n    const deferredToken = new Deferred();\n    debugState.token = deferredToken;\n    if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\n        deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\n    }\n    else {\n        deferredToken.resolve(readOrCreateDebugTokenFromStorage());\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Initial hardcoded value agreed upon across platforms for initial launch.\n// Format left open for possible dynamic error values and other fields in the future.\nconst defaultTokenErrorData = { error: 'UNKNOWN_ERROR' };\n/**\n * Stringify and base64 encode token error data.\n *\n * @param tokenError Error data, currently hardcoded.\n */\nfunction formatDummyToken(tokenErrorData) {\n    return base64.encodeString(JSON.stringify(tokenErrorData), \n    /* webSafe= */ false);\n}\n/**\n * This function always resolves.\n * The result will contain an error field if there is any error.\n * In case there is an error, the token field in the result will be populated with a dummy value\n */\nasync function getToken$2(appCheck, forceRefresh = false, shouldLogErrors = false) {\n    const app = appCheck.app;\n    ensureActivated(app);\n    const state = getStateReference(app);\n    /**\n     * First check if there is a token in memory from a previous `getToken()` call.\n     */\n    let token = state.token;\n    let error = undefined;\n    /**\n     * If an invalid token was found in memory, clear token from\n     * memory and unset the local variable `token`.\n     */\n    if (token && !isValid(token)) {\n        state.token = undefined;\n        token = undefined;\n    }\n    /**\n     * If there is no valid token in memory, try to load token from indexedDB.\n     */\n    if (!token) {\n        // cachedTokenPromise contains the token found in IndexedDB or undefined if not found.\n        const cachedToken = await state.cachedTokenPromise;\n        if (cachedToken) {\n            if (isValid(cachedToken)) {\n                token = cachedToken;\n            }\n            else {\n                // If there was an invalid token in the indexedDB cache, clear it.\n                await writeTokenToStorage(app, undefined);\n            }\n        }\n    }\n    // Return the cached token (from either memory or indexedDB) if it's valid\n    if (!forceRefresh && token && isValid(token)) {\n        return {\n            token: token.token\n        };\n    }\n    // Only set to true if this `getToken()` call is making the actual\n    // REST call to the exchange endpoint, versus waiting for an already\n    // in-flight call (see debug and regular exchange endpoint paths below)\n    let shouldCallListeners = false;\n    /**\n     * DEBUG MODE\n     * If debug mode is set, and there is no cached token, fetch a new App\n     * Check token using the debug token, and return it directly.\n     */\n    if (isDebugMode()) {\n        try {\n            // Avoid making another call to the exchange endpoint if one is in flight.\n            if (!state.exchangeTokenPromise) {\n                state.exchangeTokenPromise = exchangeToken(getExchangeDebugTokenRequest(app, await getDebugToken()), appCheck.heartbeatServiceProvider).finally(() => {\n                    // Clear promise when settled - either resolved or rejected.\n                    state.exchangeTokenPromise = undefined;\n                });\n                shouldCallListeners = true;\n            }\n            const tokenFromDebugExchange = await state.exchangeTokenPromise;\n            // Write debug token to indexedDB.\n            await writeTokenToStorage(app, tokenFromDebugExchange);\n            // Write debug token to state.\n            state.token = tokenFromDebugExchange;\n            return { token: tokenFromDebugExchange.token };\n        }\n        catch (e) {\n            if (e.code === `appCheck/${\"throttled\" /* AppCheckError.THROTTLED */}` ||\n                e.code ===\n                    `appCheck/${\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */}`) {\n                // Warn if throttled, but do not treat it as an error.\n                logger.warn(e.message);\n            }\n            else if (shouldLogErrors) {\n                logger.error(e);\n            }\n            // Return dummy token and error\n            return makeDummyTokenResult(e);\n        }\n    }\n    /**\n     * There are no valid tokens in memory or indexedDB and we are not in\n     * debug mode.\n     * Request a new token from the exchange endpoint.\n     */\n    try {\n        // Avoid making another call to the exchange endpoint if one is in flight.\n        if (!state.exchangeTokenPromise) {\n            // state.provider is populated in initializeAppCheck()\n            // ensureActivated() at the top of this function checks that\n            // initializeAppCheck() has been called.\n            state.exchangeTokenPromise = state.provider.getToken().finally(() => {\n                // Clear promise when settled - either resolved or rejected.\n                state.exchangeTokenPromise = undefined;\n            });\n            shouldCallListeners = true;\n        }\n        token = await getStateReference(app).exchangeTokenPromise;\n    }\n    catch (e) {\n        if (e.code === `appCheck/${\"throttled\" /* AppCheckError.THROTTLED */}` ||\n            e.code === `appCheck/${\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */}`) {\n            // Warn if throttled, but do not treat it as an error.\n            logger.warn(e.message);\n        }\n        else if (shouldLogErrors) {\n            logger.error(e);\n        }\n        // Always save error to be added to dummy token.\n        error = e;\n    }\n    let interopTokenResult;\n    if (!token) {\n        // If token is undefined, there must be an error.\n        // Return a dummy token along with the error.\n        interopTokenResult = makeDummyTokenResult(error);\n    }\n    else if (error) {\n        if (isValid(token)) {\n            // It's also possible a valid token exists, but there's also an error.\n            // (Such as if the token is almost expired, tries to refresh, and\n            // the exchange request fails.)\n            // We add a special error property here so that the refresher will\n            // count this as a failed attempt and use the backoff instead of\n            // retrying repeatedly with no delay, but any 3P listeners will not\n            // be hindered in getting the still-valid token.\n            interopTokenResult = {\n                token: token.token,\n                internalError: error\n            };\n        }\n        else {\n            // No invalid tokens should make it to this step. Memory and cached tokens\n            // are checked. Other tokens are from fresh exchanges. But just in case.\n            interopTokenResult = makeDummyTokenResult(error);\n        }\n    }\n    else {\n        interopTokenResult = {\n            token: token.token\n        };\n        // write the new token to the memory state as well as the persistent storage.\n        // Only do it if we got a valid new token\n        state.token = token;\n        await writeTokenToStorage(app, token);\n    }\n    if (shouldCallListeners) {\n        notifyTokenListeners(app, interopTokenResult);\n    }\n    return interopTokenResult;\n}\n/**\n * Internal API for limited use tokens. Skips all FAC state and simply calls\n * the underlying provider.\n */\nasync function getLimitedUseToken$1(appCheck) {\n    const app = appCheck.app;\n    ensureActivated(app);\n    const { provider } = getStateReference(app);\n    if (isDebugMode()) {\n        const debugToken = await getDebugToken();\n        const { token } = await exchangeToken(getExchangeDebugTokenRequest(app, debugToken), appCheck.heartbeatServiceProvider);\n        return { token };\n    }\n    else {\n        // provider is definitely valid since we ensure AppCheck was activated\n        const { token } = await provider.getToken();\n        return { token };\n    }\n}\nfunction addTokenListener(appCheck, type, listener, onError) {\n    const { app } = appCheck;\n    const state = getStateReference(app);\n    const tokenObserver = {\n        next: listener,\n        error: onError,\n        type\n    };\n    state.tokenObservers = [...state.tokenObservers, tokenObserver];\n    // Invoke the listener async immediately if there is a valid token\n    // in memory.\n    if (state.token && isValid(state.token)) {\n        const validToken = state.token;\n        Promise.resolve()\n            .then(() => {\n            listener({ token: validToken.token });\n            initTokenRefresher(appCheck);\n        })\n            .catch(() => {\n            /* we don't care about exceptions thrown in listeners */\n        });\n    }\n    /**\n     * Wait for any cached token promise to resolve before starting the token\n     * refresher. The refresher checks to see if there is an existing token\n     * in state and calls the exchange endpoint if not. We should first let the\n     * IndexedDB check have a chance to populate state if it can.\n     *\n     * Listener call isn't needed here because cachedTokenPromise will call any\n     * listeners that exist when it resolves.\n     */\n    // state.cachedTokenPromise is always populated in `activate()`.\n    void state.cachedTokenPromise.then(() => initTokenRefresher(appCheck));\n}\nfunction removeTokenListener(app, listener) {\n    const state = getStateReference(app);\n    const newObservers = state.tokenObservers.filter(tokenObserver => tokenObserver.next !== listener);\n    if (newObservers.length === 0 &&\n        state.tokenRefresher &&\n        state.tokenRefresher.isRunning()) {\n        state.tokenRefresher.stop();\n    }\n    state.tokenObservers = newObservers;\n}\n/**\n * Logic to create and start refresher as needed.\n */\nfunction initTokenRefresher(appCheck) {\n    const { app } = appCheck;\n    const state = getStateReference(app);\n    // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\n    // is not true.\n    let refresher = state.tokenRefresher;\n    if (!refresher) {\n        refresher = createTokenRefresher(appCheck);\n        state.tokenRefresher = refresher;\n    }\n    if (!refresher.isRunning() && state.isTokenAutoRefreshEnabled) {\n        refresher.start();\n    }\n}\nfunction createTokenRefresher(appCheck) {\n    const { app } = appCheck;\n    return new Refresher(\n    // Keep in mind when this fails for any reason other than the ones\n    // for which we should retry, it will effectively stop the proactive refresh.\n    async () => {\n        const state = getStateReference(app);\n        // If there is no token, we will try to load it from storage and use it\n        // If there is a token, we force refresh it because we know it's going to expire soon\n        let result;\n        if (!state.token) {\n            result = await getToken$2(appCheck);\n        }\n        else {\n            result = await getToken$2(appCheck, true);\n        }\n        /**\n         * getToken() always resolves. In case the result has an error field defined, it means\n         * the operation failed, and we should retry.\n         */\n        if (result.error) {\n            throw result.error;\n        }\n        /**\n         * A special `internalError` field reflects that there was an error\n         * getting a new token from the exchange endpoint, but there's still a\n         * previous token that's valid for now and this should be passed to 2P/3P\n         * requests for a token. But we want this callback (`this.operation` in\n         * `Refresher`) to throw in order to kick off the Refresher's retry\n         * backoff. (Setting `hasSucceeded` to false.)\n         */\n        if (result.internalError) {\n            throw result.internalError;\n        }\n    }, () => {\n        return true;\n    }, () => {\n        const state = getStateReference(app);\n        if (state.token) {\n            // issuedAtTime + (50% * total TTL) + 5 minutes\n            let nextRefreshTimeMillis = state.token.issuedAtTimeMillis +\n                (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) *\n                    0.5 +\n                5 * 60 * 1000;\n            // Do not allow refresh time to be past (expireTime - 5 minutes)\n            const latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1000;\n            nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);\n            return Math.max(0, nextRefreshTimeMillis - Date.now());\n        }\n        else {\n            return 0;\n        }\n    }, TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT, TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT);\n}\nfunction notifyTokenListeners(app, token) {\n    const observers = getStateReference(app).tokenObservers;\n    for (const observer of observers) {\n        try {\n            if (observer.type === \"EXTERNAL\" /* ListenerType.EXTERNAL */ && token.error != null) {\n                // If this listener was added by a 3P call, send any token error to\n                // the supplied error handler. A 3P observer always has an error\n                // handler.\n                observer.error(token.error);\n            }\n            else {\n                // If the token has no error field, always return the token.\n                // If this is a 2P listener, return the token, whether or not it\n                // has an error field.\n                observer.next(token);\n            }\n        }\n        catch (e) {\n            // Errors in the listener function itself are always ignored.\n        }\n    }\n}\nfunction isValid(token) {\n    return token.expireTimeMillis - Date.now() > 0;\n}\nfunction makeDummyTokenResult(error) {\n    return {\n        token: formatDummyToken(defaultTokenErrorData),\n        error\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * AppCheck Service class.\n */\nclass AppCheckService {\n    constructor(app, heartbeatServiceProvider) {\n        this.app = app;\n        this.heartbeatServiceProvider = heartbeatServiceProvider;\n    }\n    _delete() {\n        const { tokenObservers } = getStateReference(this.app);\n        for (const tokenObserver of tokenObservers) {\n            removeTokenListener(this.app, tokenObserver.next);\n        }\n        return Promise.resolve();\n    }\n}\nfunction factory(app, heartbeatServiceProvider) {\n    return new AppCheckService(app, heartbeatServiceProvider);\n}\nfunction internalFactory(appCheck) {\n    return {\n        getToken: forceRefresh => getToken$2(appCheck, forceRefresh),\n        getLimitedUseToken: () => getLimitedUseToken$1(appCheck),\n        addTokenListener: listener => addTokenListener(appCheck, \"INTERNAL\" /* ListenerType.INTERNAL */, listener),\n        removeTokenListener: listener => removeTokenListener(appCheck.app, listener)\n    };\n}\n\nconst name = \"@firebase/app-check\";\nconst version = \"0.10.0\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\nconst RECAPTCHA_ENTERPRISE_URL = 'https://www.google.com/recaptcha/enterprise.js';\nfunction initializeV3(app, siteKey) {\n    const initialized = new Deferred();\n    const state = getStateReference(app);\n    state.reCAPTCHAState = { initialized };\n    const divId = makeDiv(app);\n    const grecaptcha = getRecaptcha(false);\n    if (!grecaptcha) {\n        loadReCAPTCHAV3Script(() => {\n            const grecaptcha = getRecaptcha(false);\n            if (!grecaptcha) {\n                // it shouldn't happen.\n                throw new Error('no recaptcha');\n            }\n            queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n        });\n    }\n    else {\n        queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    }\n    return initialized.promise;\n}\nfunction initializeEnterprise(app, siteKey) {\n    const initialized = new Deferred();\n    const state = getStateReference(app);\n    state.reCAPTCHAState = { initialized };\n    const divId = makeDiv(app);\n    const grecaptcha = getRecaptcha(true);\n    if (!grecaptcha) {\n        loadReCAPTCHAEnterpriseScript(() => {\n            const grecaptcha = getRecaptcha(true);\n            if (!grecaptcha) {\n                // it shouldn't happen.\n                throw new Error('no recaptcha');\n            }\n            queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n        });\n    }\n    else {\n        queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    }\n    return initialized.promise;\n}\n/**\n * Add listener to render the widget and resolve the promise when\n * the grecaptcha.ready() event fires.\n */\nfunction queueWidgetRender(app, siteKey, grecaptcha, container, initialized) {\n    grecaptcha.ready(() => {\n        // Invisible widgets allow us to set a different siteKey for each widget,\n        // so we use them to support multiple apps\n        renderInvisibleWidget(app, siteKey, grecaptcha, container);\n        initialized.resolve(grecaptcha);\n    });\n}\n/**\n * Add invisible div to page.\n */\nfunction makeDiv(app) {\n    const divId = `fire_app_check_${app.name}`;\n    const invisibleDiv = document.createElement('div');\n    invisibleDiv.id = divId;\n    invisibleDiv.style.display = 'none';\n    document.body.appendChild(invisibleDiv);\n    return divId;\n}\nasync function getToken$1(app) {\n    ensureActivated(app);\n    // ensureActivated() guarantees that reCAPTCHAState is set\n    const reCAPTCHAState = getStateReference(app).reCAPTCHAState;\n    const recaptcha = await reCAPTCHAState.initialized.promise;\n    return new Promise((resolve, _reject) => {\n        // Updated after initialization is complete.\n        const reCAPTCHAState = getStateReference(app).reCAPTCHAState;\n        recaptcha.ready(() => {\n            resolve(\n            // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\n            recaptcha.execute(reCAPTCHAState.widgetId, {\n                action: 'fire_app_check'\n            }));\n        });\n    });\n}\n/**\n *\n * @param app\n * @param container - Id of a HTML element.\n */\nfunction renderInvisibleWidget(app, siteKey, grecaptcha, container) {\n    const widgetId = grecaptcha.render(container, {\n        sitekey: siteKey,\n        size: 'invisible',\n        // Success callback - set state\n        callback: () => {\n            getStateReference(app).reCAPTCHAState.succeeded = true;\n        },\n        // Failure callback - set state\n        'error-callback': () => {\n            getStateReference(app).reCAPTCHAState.succeeded = false;\n        }\n    });\n    const state = getStateReference(app);\n    state.reCAPTCHAState = Object.assign(Object.assign({}, state.reCAPTCHAState), { // state.reCAPTCHAState is set in the initialize()\n        widgetId });\n}\nfunction loadReCAPTCHAV3Script(onload) {\n    const script = document.createElement('script');\n    script.src = RECAPTCHA_URL;\n    script.onload = onload;\n    document.head.appendChild(script);\n}\nfunction loadReCAPTCHAEnterpriseScript(onload) {\n    const script = document.createElement('script');\n    script.src = RECAPTCHA_ENTERPRISE_URL;\n    script.onload = onload;\n    document.head.appendChild(script);\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * App Check provider that can obtain a reCAPTCHA V3 token and exchange it\n * for an App Check token.\n *\n * @public\n */\nclass ReCaptchaV3Provider {\n    /**\n     * Create a ReCaptchaV3Provider instance.\n     * @param siteKey - ReCAPTCHA V3 siteKey.\n     */\n    constructor(_siteKey) {\n        this._siteKey = _siteKey;\n        /**\n         * Throttle requests on certain error codes to prevent too many retries\n         * in a short time.\n         */\n        this._throttleData = null;\n    }\n    /**\n     * Returns an App Check token.\n     * @internal\n     */\n    async getToken() {\n        var _a, _b, _c;\n        throwIfThrottled(this._throttleData);\n        // Top-level `getToken()` has already checked that App Check is initialized\n        // and therefore this._app and this._heartbeatServiceProvider are available.\n        const attestedClaimsToken = await getToken$1(this._app).catch(_e => {\n            // reCaptcha.execute() throws null which is not very descriptive.\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n        });\n        // Check if a failure state was set by the recaptcha \"error-callback\".\n        if (!((_a = getStateReference(this._app).reCAPTCHAState) === null || _a === void 0 ? void 0 : _a.succeeded)) {\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n        }\n        let result;\n        try {\n            result = await exchangeToken(getExchangeRecaptchaV3TokenRequest(this._app, attestedClaimsToken), this._heartbeatServiceProvider);\n        }\n        catch (e) {\n            if ((_b = e.code) === null || _b === void 0 ? void 0 : _b.includes(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */)) {\n                this._throttleData = setBackoff(Number((_c = e.customData) === null || _c === void 0 ? void 0 : _c.httpStatus), this._throttleData);\n                throw ERROR_FACTORY.create(\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */, {\n                    time: getDurationString(this._throttleData.allowRequestsAfter - Date.now()),\n                    httpStatus: this._throttleData.httpStatus\n                });\n            }\n            else {\n                throw e;\n            }\n        }\n        // If successful, clear throttle data.\n        this._throttleData = null;\n        return result;\n    }\n    /**\n     * @internal\n     */\n    initialize(app) {\n        this._app = app;\n        this._heartbeatServiceProvider = _getProvider(app, 'heartbeat');\n        initializeV3(app, this._siteKey).catch(() => {\n            /* we don't care about the initialization result */\n        });\n    }\n    /**\n     * @internal\n     */\n    isEqual(otherProvider) {\n        if (otherProvider instanceof ReCaptchaV3Provider) {\n            return this._siteKey === otherProvider._siteKey;\n        }\n        else {\n            return false;\n        }\n    }\n}\n/**\n * App Check provider that can obtain a reCAPTCHA Enterprise token and exchange it\n * for an App Check token.\n *\n * @public\n */\nclass ReCaptchaEnterpriseProvider {\n    /**\n     * Create a ReCaptchaEnterpriseProvider instance.\n     * @param siteKey - reCAPTCHA Enterprise score-based site key.\n     */\n    constructor(_siteKey) {\n        this._siteKey = _siteKey;\n        /**\n         * Throttle requests on certain error codes to prevent too many retries\n         * in a short time.\n         */\n        this._throttleData = null;\n    }\n    /**\n     * Returns an App Check token.\n     * @internal\n     */\n    async getToken() {\n        var _a, _b, _c;\n        throwIfThrottled(this._throttleData);\n        // Top-level `getToken()` has already checked that App Check is initialized\n        // and therefore this._app and this._heartbeatServiceProvider are available.\n        const attestedClaimsToken = await getToken$1(this._app).catch(_e => {\n            // reCaptcha.execute() throws null which is not very descriptive.\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n        });\n        // Check if a failure state was set by the recaptcha \"error-callback\".\n        if (!((_a = getStateReference(this._app).reCAPTCHAState) === null || _a === void 0 ? void 0 : _a.succeeded)) {\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n        }\n        let result;\n        try {\n            result = await exchangeToken(getExchangeRecaptchaEnterpriseTokenRequest(this._app, attestedClaimsToken), this._heartbeatServiceProvider);\n        }\n        catch (e) {\n            if ((_b = e.code) === null || _b === void 0 ? void 0 : _b.includes(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */)) {\n                this._throttleData = setBackoff(Number((_c = e.customData) === null || _c === void 0 ? void 0 : _c.httpStatus), this._throttleData);\n                throw ERROR_FACTORY.create(\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */, {\n                    time: getDurationString(this._throttleData.allowRequestsAfter - Date.now()),\n                    httpStatus: this._throttleData.httpStatus\n                });\n            }\n            else {\n                throw e;\n            }\n        }\n        // If successful, clear throttle data.\n        this._throttleData = null;\n        return result;\n    }\n    /**\n     * @internal\n     */\n    initialize(app) {\n        this._app = app;\n        this._heartbeatServiceProvider = _getProvider(app, 'heartbeat');\n        initializeEnterprise(app, this._siteKey).catch(() => {\n            /* we don't care about the initialization result */\n        });\n    }\n    /**\n     * @internal\n     */\n    isEqual(otherProvider) {\n        if (otherProvider instanceof ReCaptchaEnterpriseProvider) {\n            return this._siteKey === otherProvider._siteKey;\n        }\n        else {\n            return false;\n        }\n    }\n}\n/**\n * Custom provider class.\n * @public\n */\nclass CustomProvider {\n    constructor(_customProviderOptions) {\n        this._customProviderOptions = _customProviderOptions;\n    }\n    /**\n     * @internal\n     */\n    async getToken() {\n        // custom provider\n        const customToken = await this._customProviderOptions.getToken();\n        // Try to extract IAT from custom token, in case this token is not\n        // being newly issued. JWT timestamps are in seconds since epoch.\n        const issuedAtTimeSeconds = issuedAtTime(customToken.token);\n        // Very basic validation, use current timestamp as IAT if JWT\n        // has no `iat` field or value is out of bounds.\n        const issuedAtTimeMillis = issuedAtTimeSeconds !== null &&\n            issuedAtTimeSeconds < Date.now() &&\n            issuedAtTimeSeconds > 0\n            ? issuedAtTimeSeconds * 1000\n            : Date.now();\n        return Object.assign(Object.assign({}, customToken), { issuedAtTimeMillis });\n    }\n    /**\n     * @internal\n     */\n    initialize(app) {\n        this._app = app;\n    }\n    /**\n     * @internal\n     */\n    isEqual(otherProvider) {\n        if (otherProvider instanceof CustomProvider) {\n            return (this._customProviderOptions.getToken.toString() ===\n                otherProvider._customProviderOptions.getToken.toString());\n        }\n        else {\n            return false;\n        }\n    }\n}\n/**\n * Set throttle data to block requests until after a certain time\n * depending on the failed request's status code.\n * @param httpStatus - Status code of failed request.\n * @param throttleData - `ThrottleData` object containing previous throttle\n * data state.\n * @returns Data about current throttle state and expiration time.\n */\nfunction setBackoff(httpStatus, throttleData) {\n    /**\n     * Block retries for 1 day for the following error codes:\n     *\n     * 404: Likely malformed URL.\n     *\n     * 403:\n     * - Attestation failed\n     * - Wrong API key\n     * - Project deleted\n     */\n    if (httpStatus === 404 || httpStatus === 403) {\n        return {\n            backoffCount: 1,\n            allowRequestsAfter: Date.now() + ONE_DAY,\n            httpStatus\n        };\n    }\n    else {\n        /**\n         * For all other error codes, the time when it is ok to retry again\n         * is based on exponential backoff.\n         */\n        const backoffCount = throttleData ? throttleData.backoffCount : 0;\n        const backoffMillis = calculateBackoffMillis(backoffCount, 1000, 2);\n        return {\n            backoffCount: backoffCount + 1,\n            allowRequestsAfter: Date.now() + backoffMillis,\n            httpStatus\n        };\n    }\n}\nfunction throwIfThrottled(throttleData) {\n    if (throttleData) {\n        if (Date.now() - throttleData.allowRequestsAfter <= 0) {\n            // If before, throw.\n            throw ERROR_FACTORY.create(\"throttled\" /* AppCheckError.THROTTLED */, {\n                time: getDurationString(throttleData.allowRequestsAfter - Date.now()),\n                httpStatus: throttleData.httpStatus\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Activate App Check for the given app. Can be called only once per app.\n * @param app - the {@link @firebase/app#FirebaseApp} to activate App Check for\n * @param options - App Check initialization options\n * @public\n */\nfunction initializeAppCheck(app = getApp(), options) {\n    app = getModularInstance(app);\n    const provider = _getProvider(app, 'app-check');\n    // Ensure initializeDebugMode() is only called once.\n    if (!getDebugState().initialized) {\n        initializeDebugMode();\n    }\n    // Log a message containing the debug token when `initializeAppCheck()`\n    // is called in debug mode.\n    if (isDebugMode()) {\n        // Do not block initialization to get the token for the message.\n        void getDebugToken().then(token => \n        // Not using logger because I don't think we ever want this accidentally hidden.\n        console.log(`App Check debug token: ${token}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`));\n    }\n    if (provider.isInitialized()) {\n        const existingInstance = provider.getImmediate();\n        const initialOptions = provider.getOptions();\n        if (initialOptions.isTokenAutoRefreshEnabled ===\n            options.isTokenAutoRefreshEnabled &&\n            initialOptions.provider.isEqual(options.provider)) {\n            return existingInstance;\n        }\n        else {\n            throw ERROR_FACTORY.create(\"already-initialized\" /* AppCheckError.ALREADY_INITIALIZED */, {\n                appName: app.name\n            });\n        }\n    }\n    const appCheck = provider.initialize({ options });\n    _activate(app, options.provider, options.isTokenAutoRefreshEnabled);\n    // If isTokenAutoRefreshEnabled is false, do not send any requests to the\n    // exchange endpoint without an explicit call from the user either directly\n    // or through another Firebase library (storage, functions, etc.)\n    if (getStateReference(app).isTokenAutoRefreshEnabled) {\n        // Adding a listener will start the refresher and fetch a token if needed.\n        // This gets a token ready and prevents a delay when an internal library\n        // requests the token.\n        // Listener function does not need to do anything, its base functionality\n        // of calling getToken() already fetches token and writes it to memory/storage.\n        addTokenListener(appCheck, \"INTERNAL\" /* ListenerType.INTERNAL */, () => { });\n    }\n    return appCheck;\n}\n/**\n * Activate App Check\n * @param app - Firebase app to activate App Check for.\n * @param provider - reCAPTCHA v3 provider or\n * custom token provider.\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\n * refreshes App Check tokens as needed. If undefined, defaults to the\n * value of `app.automaticDataCollectionEnabled`, which defaults to\n * false and can be set in the app config.\n */\nfunction _activate(app, provider, isTokenAutoRefreshEnabled = false) {\n    // Create an entry in the APP_CHECK_STATES map. Further changes should\n    // directly mutate this object.\n    const state = setInitialState(app, Object.assign({}, DEFAULT_STATE));\n    state.activated = true;\n    state.provider = provider; // Read cached token from storage if it exists and store it in memory.\n    state.cachedTokenPromise = readTokenFromStorage(app).then(cachedToken => {\n        if (cachedToken && isValid(cachedToken)) {\n            state.token = cachedToken;\n            // notify all listeners with the cached token\n            notifyTokenListeners(app, { token: cachedToken.token });\n        }\n        return cachedToken;\n    });\n    // Global `automaticDataCollectionEnabled` (defaults to true) and\n    // `isTokenAutoRefreshEnabled` must both be true.\n    state.isTokenAutoRefreshEnabled =\n        isTokenAutoRefreshEnabled && app.automaticDataCollectionEnabled;\n    if (!app.automaticDataCollectionEnabled && isTokenAutoRefreshEnabled) {\n        logger.warn('`isTokenAutoRefreshEnabled` is true but ' +\n            '`automaticDataCollectionEnabled` was set to false during' +\n            ' `initializeApp()`. This blocks automatic token refresh.');\n    }\n    state.provider.initialize(app);\n}\n/**\n * Set whether App Check will automatically refresh tokens as needed.\n *\n * @param appCheckInstance - The App Check service instance.\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\n * refreshes App Check tokens as needed. This overrides any value set\n * during `initializeAppCheck()`.\n * @public\n */\nfunction setTokenAutoRefreshEnabled(appCheckInstance, isTokenAutoRefreshEnabled) {\n    const app = appCheckInstance.app;\n    const state = getStateReference(app);\n    // This will exist if any product libraries have called\n    // `addTokenListener()`\n    if (state.tokenRefresher) {\n        if (isTokenAutoRefreshEnabled === true) {\n            state.tokenRefresher.start();\n        }\n        else {\n            state.tokenRefresher.stop();\n        }\n    }\n    state.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled;\n}\n/**\n * Get the current App Check token. If `forceRefresh` is false, this function first\n * checks for a valid token in memory, then local persistence (IndexedDB).\n * If not found, or if `forceRefresh` is true, it makes a request to the\n * App Check endpoint for a fresh token. That request attaches\n * to the most recent in-flight request if one is present.\n *\n * @param appCheckInstance - The App Check service instance.\n * @param forceRefresh - If true, will always try to fetch a fresh token.\n * If false, will use a cached token if found in storage.\n * @public\n */\nasync function getToken(appCheckInstance, forceRefresh) {\n    const result = await getToken$2(appCheckInstance, forceRefresh);\n    if (result.error) {\n        throw result.error;\n    }\n    if (result.internalError) {\n        throw result.internalError;\n    }\n    return { token: result.token };\n}\n/**\n * Requests a Firebase App Check token. This method should be used\n * only if you need to authorize requests to a non-Firebase backend.\n *\n * Returns limited-use tokens that are intended for use with your\n * non-Firebase backend endpoints that are protected with\n * <a href=\"https://firebase.google.com/docs/app-check/custom-resource-backend#replay-protection\">\n * Replay Protection</a>. This method\n * does not affect the token generation behavior of the\n * #getAppCheckToken() method.\n *\n * @param appCheckInstance - The App Check service instance.\n * @returns The limited use token.\n * @public\n */\nfunction getLimitedUseToken(appCheckInstance) {\n    return getLimitedUseToken$1(appCheckInstance);\n}\n/**\n * Wraps `addTokenListener`/`removeTokenListener` methods in an `Observer`\n * pattern for public use.\n */\nfunction onTokenChanged(appCheckInstance, onNextOrObserver, onError, \n/**\n * NOTE: Although an `onCompletion` callback can be provided, it will\n * never be called because the token stream is never-ending.\n * It is added only for API consistency with the observer pattern, which\n * we follow in JS APIs.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nonCompletion) {\n    let nextFn = () => { };\n    let errorFn = () => { };\n    if (onNextOrObserver.next != null) {\n        nextFn = onNextOrObserver.next.bind(onNextOrObserver);\n    }\n    else {\n        nextFn = onNextOrObserver;\n    }\n    if (onNextOrObserver.error != null) {\n        errorFn = onNextOrObserver.error.bind(onNextOrObserver);\n    }\n    else if (onError) {\n        errorFn = onError;\n    }\n    addTokenListener(appCheckInstance, \"EXTERNAL\" /* ListenerType.EXTERNAL */, nextFn, errorFn);\n    return () => removeTokenListener(appCheckInstance.app, nextFn);\n}\n\n/**\n * The Firebase App Check Web SDK.\n *\n * @remarks\n * Firebase App Check does not work in a Node.js environment using `ReCaptchaV3Provider` or\n * `ReCaptchaEnterpriseProvider`, but can be used in Node.js if you use\n * `CustomProvider` and write your own attestation method.\n *\n * @packageDocumentation\n */\nconst APP_CHECK_NAME = 'app-check';\nconst APP_CHECK_NAME_INTERNAL = 'app-check-internal';\nfunction registerAppCheck() {\n    // The public interface\n    _registerComponent(new Component(APP_CHECK_NAME, container => {\n        // getImmediate for FirebaseApp will always succeed\n        const app = container.getProvider('app').getImmediate();\n        const heartbeatServiceProvider = container.getProvider('heartbeat');\n        return factory(app, heartbeatServiceProvider);\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */)\n        .setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */)\n        /**\n         * Initialize app-check-internal after app-check is initialized to make AppCheck available to\n         * other Firebase SDKs\n         */\n        .setInstanceCreatedCallback((container, _identifier, _appcheckService) => {\n        container.getProvider(APP_CHECK_NAME_INTERNAL).initialize();\n    }));\n    // The internal interface used by other Firebase products\n    _registerComponent(new Component(APP_CHECK_NAME_INTERNAL, container => {\n        const appCheck = container.getProvider('app-check').getImmediate();\n        return internalFactory(appCheck);\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */));\n    registerVersion(name, version);\n}\nregisterAppCheck();\n\nexport { CustomProvider, ReCaptchaEnterpriseProvider, ReCaptchaV3Provider, getLimitedUseToken, getToken, initializeAppCheck, onTokenChanged, setTokenAutoRefreshEnabled };\n\n", "import { ɵgetAllInstancesOf as _getAllInstancesOf, ɵgetDefaultInstanceOf as _getDefaultInstanceOf, VERSION, ɵAngularFireSchedulers as _AngularFireSchedulers, ɵzoneWrap as _zoneWrap } from '@angular/fire';\nimport { timer, from } from 'rxjs';\nimport { concatMap, distinct } from 'rxjs/operators';\nimport { isPlatformServer } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, Optional, PLATFORM_ID, NgModule, makeEnvironmentProviders, NgZone, Injector } from '@angular/core';\nimport { FirebaseApp, FirebaseApps } from '@angular/fire/app';\nimport { registerVersion } from 'firebase/app';\nimport { getLimitedUseToken as getLimitedUseToken$1, getToken as getToken$1, initializeAppCheck as initializeAppCheck$1, onTokenChanged as onTokenChanged$1, setTokenAutoRefreshEnabled as setTokenAutoRefreshEnabled$1 } from 'firebase/app-check';\nexport * from 'firebase/app-check';\nconst APP_CHECK_PROVIDER_NAME = 'app-check';\nclass AppCheck {\n  constructor(appCheck) {\n    return appCheck;\n  }\n}\nclass AppCheckInstances {\n  constructor() {\n    return _getAllInstancesOf(APP_CHECK_PROVIDER_NAME);\n  }\n}\nconst appCheckInstance$ = timer(0, 300).pipe(concatMap(() => from(_getAllInstancesOf(APP_CHECK_PROVIDER_NAME))), distinct());\nconst PROVIDED_APP_CHECK_INSTANCES = new InjectionToken('angularfire2.app-check-instances');\nfunction defaultAppCheckInstanceFactory(provided, defaultApp) {\n  const defaultAppCheck = _getDefaultInstanceOf(APP_CHECK_PROVIDER_NAME, provided, defaultApp);\n  return defaultAppCheck && new AppCheck(defaultAppCheck);\n}\nconst LOCALHOSTS = ['localhost', '0.0.0.0', '127.0.0.1'];\nconst isLocalhost = typeof window !== 'undefined' && LOCALHOSTS.includes(window.location.hostname);\nfunction appCheckInstanceFactory(fn) {\n  return (zone, injector, platformId) => {\n    // Node should use admin token provider, browser devmode and localhost should use debug token\n    if (!isPlatformServer(platformId) && (isDevMode() || isLocalhost)) {\n      globalThis.FIREBASE_APPCHECK_DEBUG_TOKEN ??= true;\n    }\n    const appCheck = zone.runOutsideAngular(() => fn(injector));\n    return new AppCheck(appCheck);\n  };\n}\nconst APP_CHECK_INSTANCES_PROVIDER = {\n  provide: AppCheckInstances,\n  deps: [[new Optional(), PROVIDED_APP_CHECK_INSTANCES]]\n};\nconst DEFAULT_APP_CHECK_INSTANCE_PROVIDER = {\n  provide: AppCheck,\n  useFactory: defaultAppCheckInstanceFactory,\n  deps: [[new Optional(), PROVIDED_APP_CHECK_INSTANCES], FirebaseApp, PLATFORM_ID]\n};\nclass AppCheckModule {\n  constructor() {\n    registerVersion('angularfire', VERSION.full, 'app-check');\n  }\n  static ɵfac = function AppCheckModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || AppCheckModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AppCheckModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [DEFAULT_APP_CHECK_INSTANCE_PROVIDER, APP_CHECK_INSTANCES_PROVIDER]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AppCheckModule, [{\n    type: NgModule,\n    args: [{\n      providers: [DEFAULT_APP_CHECK_INSTANCE_PROVIDER, APP_CHECK_INSTANCES_PROVIDER]\n    }]\n  }], () => [], null);\n})();\nfunction provideAppCheck(fn, ...deps) {\n  registerVersion('angularfire', VERSION.full, 'app-check');\n  return makeEnvironmentProviders([DEFAULT_APP_CHECK_INSTANCE_PROVIDER, APP_CHECK_INSTANCES_PROVIDER, {\n    provide: PROVIDED_APP_CHECK_INSTANCES,\n    useFactory: appCheckInstanceFactory(fn),\n    multi: true,\n    deps: [NgZone, Injector, PLATFORM_ID, _AngularFireSchedulers, FirebaseApps, ...deps]\n  }]);\n}\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst getLimitedUseToken = _zoneWrap(getLimitedUseToken$1, true, 2);\nconst getToken = _zoneWrap(getToken$1, true);\nconst initializeAppCheck = _zoneWrap(initializeAppCheck$1, true);\nconst onTokenChanged = _zoneWrap(onTokenChanged$1, true);\nconst setTokenAutoRefreshEnabled = _zoneWrap(setTokenAutoRefreshEnabled$1, true);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AppCheck, AppCheckInstances, AppCheckModule, appCheckInstance$, getLimitedUseToken, getToken, initializeAppCheck, onTokenChanged, provideAppCheck, setTokenAutoRefreshEnabled };\n", "import { onAuthStateChanged, onIdTokenChanged, getIdToken } from 'firebase/auth';\nimport { Observable, from, of } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Create an observable of authentication state. The observer is only\n * triggered on sign-in or sign-out.\n * @param auth firebase.auth.Auth\n */\nfunction authState(auth) {\n    return new Observable(function (subscriber) {\n        var unsubscribe = onAuthStateChanged(auth, subscriber.next.bind(subscriber), subscriber.error.bind(subscriber), subscriber.complete.bind(subscriber));\n        return { unsubscribe: unsubscribe };\n    });\n}\n/**\n * Create an observable of user state. The observer is triggered for sign-in,\n * sign-out, and token refresh events\n * @param auth firebase.auth.Auth\n */\nfunction user(auth) {\n    return new Observable(function (subscriber) {\n        var unsubscribe = onIdTokenChanged(auth, subscriber.next.bind(subscriber), subscriber.error.bind(subscriber), subscriber.complete.bind(subscriber));\n        return { unsubscribe: unsubscribe };\n    });\n}\n/**\n * Create an observable of idToken state. The observer is triggered for sign-in,\n * sign-out, and token refresh events\n * @param auth firebase.auth.Auth\n */\nfunction idToken(auth) {\n    return user(auth).pipe(switchMap(function (user) { return (user ? from(getIdToken(user)) : of(null)); }));\n}\n\nexport { authState, idToken, user };\n\n", "import { ɵgetAllInstancesOf as _getAllInstancesOf, ɵgetDefaultInstanceOf as _getDefaultInstanceOf, VERSION, ɵAngularFireSchedulers as _AngularFireSchedulers, ɵzoneWrap as _zoneWrap } from '@angular/fire';\nimport { timer, from } from 'rxjs';\nimport { concatMap, distinct } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Optional, NgModule, makeEnvironmentProviders, NgZone, Injector } from '@angular/core';\nimport { FirebaseApp, FirebaseApps } from '@angular/fire/app';\nimport { AppCheckInstances } from '@angular/fire/app-check';\nimport { registerVersion } from 'firebase/app';\nimport { authState as authState$1, idToken as idToken$1, user as user$1 } from 'rxfire/auth';\nimport { applyActionCode as applyActionCode$1, beforeAuthStateChanged as beforeAuthStateChanged$1, checkActionCode as checkActionCode$1, confirmPasswordReset as confirmPasswordReset$1, connectAuthEmulator as connectAuthEmulator$1, createUserWithEmailAndPassword as createUserWithEmailAndPassword$1, deleteUser as deleteUser$1, fetchSignInMethodsForEmail as fetchSignInMethodsForEmail$1, getAdditionalUserInfo as getAdditionalUserInfo$1, getAuth as getAuth$1, getIdToken as getIdToken$1, getIdTokenResult as getIdTokenResult$1, getMultiFactorResolver as getMultiFactorResolver$1, getRedirectResult as getRedirectResult$1, initializeAuth as initializeAuth$1, initializeRecaptchaConfig as initializeRecaptchaConfig$1, isSignInWithEmailLink as isSignInWithEmailLink$1, linkWithCredential as linkWithCredential$1, linkWithPhoneNumber as linkWithPhoneNumber$1, linkWithPopup as linkWithPopup$1, linkWithRedirect as linkWithRedirect$1, onAuthStateChanged as onAuthStateChanged$1, onIdTokenChanged as onIdTokenChanged$1, parseActionCodeURL as parseActionCodeURL$1, reauthenticateWithCredential as reauthenticateWithCredential$1, reauthenticateWithPhoneNumber as reauthenticateWithPhoneNumber$1, reauthenticateWithPopup as reauthenticateWithPopup$1, reauthenticateWithRedirect as reauthenticateWithRedirect$1, reload as reload$1, revokeAccessToken as revokeAccessToken$1, sendEmailVerification as sendEmailVerification$1, sendPasswordResetEmail as sendPasswordResetEmail$1, sendSignInLinkToEmail as sendSignInLinkToEmail$1, setPersistence as setPersistence$1, signInAnonymously as signInAnonymously$1, signInWithCredential as signInWithCredential$1, signInWithCustomToken as signInWithCustomToken$1, signInWithEmailAndPassword as signInWithEmailAndPassword$1, signInWithEmailLink as signInWithEmailLink$1, signInWithPhoneNumber as signInWithPhoneNumber$1, signInWithPopup as signInWithPopup$1, signInWithRedirect as signInWithRedirect$1, signOut as signOut$1, unlink as unlink$1, updateCurrentUser as updateCurrentUser$1, updateEmail as updateEmail$1, updatePassword as updatePassword$1, updatePhoneNumber as updatePhoneNumber$1, updateProfile as updateProfile$1, useDeviceLanguage as useDeviceLanguage$1, validatePassword as validatePassword$1, verifyBeforeUpdateEmail as verifyBeforeUpdateEmail$1, verifyPasswordResetCode as verifyPasswordResetCode$1 } from 'firebase/auth';\nexport * from 'firebase/auth';\nconst AUTH_PROVIDER_NAME = 'auth';\nclass Auth {\n  constructor(auth) {\n    return auth;\n  }\n}\nclass AuthInstances {\n  constructor() {\n    return _getAllInstancesOf(AUTH_PROVIDER_NAME);\n  }\n}\nconst authInstance$ = timer(0, 300).pipe(concatMap(() => from(_getAllInstancesOf(AUTH_PROVIDER_NAME))), distinct());\nconst PROVIDED_AUTH_INSTANCES = new InjectionToken('angularfire2.auth-instances');\nfunction defaultAuthInstanceFactory(provided, defaultApp) {\n  const defaultAuth = _getDefaultInstanceOf(AUTH_PROVIDER_NAME, provided, defaultApp);\n  return defaultAuth && new Auth(defaultAuth);\n}\nfunction authInstanceFactory(fn) {\n  return (zone, injector) => {\n    const auth = zone.runOutsideAngular(() => fn(injector));\n    return new Auth(auth);\n  };\n}\nconst AUTH_INSTANCES_PROVIDER = {\n  provide: AuthInstances,\n  deps: [[new Optional(), PROVIDED_AUTH_INSTANCES]]\n};\nconst DEFAULT_AUTH_INSTANCE_PROVIDER = {\n  provide: Auth,\n  useFactory: defaultAuthInstanceFactory,\n  deps: [[new Optional(), PROVIDED_AUTH_INSTANCES], FirebaseApp]\n};\nclass AuthModule {\n  constructor() {\n    registerVersion('angularfire', VERSION.full, 'auth');\n  }\n  static ɵfac = function AuthModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || AuthModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AuthModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [DEFAULT_AUTH_INSTANCE_PROVIDER, AUTH_INSTANCES_PROVIDER]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AuthModule, [{\n    type: NgModule,\n    args: [{\n      providers: [DEFAULT_AUTH_INSTANCE_PROVIDER, AUTH_INSTANCES_PROVIDER]\n    }]\n  }], () => [], null);\n})();\nfunction provideAuth(fn, ...deps) {\n  registerVersion('angularfire', VERSION.full, 'auth');\n  return makeEnvironmentProviders([DEFAULT_AUTH_INSTANCE_PROVIDER, AUTH_INSTANCES_PROVIDER, {\n    provide: PROVIDED_AUTH_INSTANCES,\n    useFactory: authInstanceFactory(fn),\n    multi: true,\n    deps: [NgZone, Injector, _AngularFireSchedulers, FirebaseApps, [new Optional(), AppCheckInstances], ...deps]\n  }]);\n}\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst authState = _zoneWrap(authState$1, true);\nconst idToken = _zoneWrap(idToken$1, true);\nconst user = _zoneWrap(user$1, true);\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst applyActionCode = _zoneWrap(applyActionCode$1, true);\nconst beforeAuthStateChanged = _zoneWrap(beforeAuthStateChanged$1, true);\nconst checkActionCode = _zoneWrap(checkActionCode$1, true);\nconst confirmPasswordReset = _zoneWrap(confirmPasswordReset$1, true, 2);\nconst connectAuthEmulator = _zoneWrap(connectAuthEmulator$1, true);\nconst createUserWithEmailAndPassword = _zoneWrap(createUserWithEmailAndPassword$1, true, 2);\nconst deleteUser = _zoneWrap(deleteUser$1, true, 2);\nconst fetchSignInMethodsForEmail = _zoneWrap(fetchSignInMethodsForEmail$1, true, 2);\nconst getAdditionalUserInfo = _zoneWrap(getAdditionalUserInfo$1, true, 2);\nconst getAuth = _zoneWrap(getAuth$1, true);\nconst getIdToken = _zoneWrap(getIdToken$1, true);\nconst getIdTokenResult = _zoneWrap(getIdTokenResult$1, true);\nconst getMultiFactorResolver = _zoneWrap(getMultiFactorResolver$1, true);\nconst getRedirectResult = _zoneWrap(getRedirectResult$1, true);\nconst initializeAuth = _zoneWrap(initializeAuth$1, true);\nconst initializeRecaptchaConfig = _zoneWrap(initializeRecaptchaConfig$1, true);\nconst isSignInWithEmailLink = _zoneWrap(isSignInWithEmailLink$1, true);\nconst linkWithCredential = _zoneWrap(linkWithCredential$1, true, 2);\nconst linkWithPhoneNumber = _zoneWrap(linkWithPhoneNumber$1, true, 2);\nconst linkWithPopup = _zoneWrap(linkWithPopup$1, true, 2);\nconst linkWithRedirect = _zoneWrap(linkWithRedirect$1, true, 2);\nconst onAuthStateChanged = _zoneWrap(onAuthStateChanged$1, true);\nconst onIdTokenChanged = _zoneWrap(onIdTokenChanged$1, true);\nconst parseActionCodeURL = _zoneWrap(parseActionCodeURL$1, true);\nconst reauthenticateWithCredential = _zoneWrap(reauthenticateWithCredential$1, true, 2);\nconst reauthenticateWithPhoneNumber = _zoneWrap(reauthenticateWithPhoneNumber$1, true, 2);\nconst reauthenticateWithPopup = _zoneWrap(reauthenticateWithPopup$1, true, 2);\nconst reauthenticateWithRedirect = _zoneWrap(reauthenticateWithRedirect$1, true, 2);\nconst reload = _zoneWrap(reload$1, true, 2);\nconst revokeAccessToken = _zoneWrap(revokeAccessToken$1, true, 2);\nconst sendEmailVerification = _zoneWrap(sendEmailVerification$1, true, 2);\nconst sendPasswordResetEmail = _zoneWrap(sendPasswordResetEmail$1, true, 2);\nconst sendSignInLinkToEmail = _zoneWrap(sendSignInLinkToEmail$1, true, 2);\nconst setPersistence = _zoneWrap(setPersistence$1, true);\nconst signInAnonymously = _zoneWrap(signInAnonymously$1, true, 2);\nconst signInWithCredential = _zoneWrap(signInWithCredential$1, true, 2);\nconst signInWithCustomToken = _zoneWrap(signInWithCustomToken$1, true, 2);\nconst signInWithEmailAndPassword = _zoneWrap(signInWithEmailAndPassword$1, true, 2);\nconst signInWithEmailLink = _zoneWrap(signInWithEmailLink$1, true, 2);\nconst signInWithPhoneNumber = _zoneWrap(signInWithPhoneNumber$1, true, 2);\nconst signInWithPopup = _zoneWrap(signInWithPopup$1, true, 2);\nconst signInWithRedirect = _zoneWrap(signInWithRedirect$1, true, 2);\nconst signOut = _zoneWrap(signOut$1, true, 2);\nconst unlink = _zoneWrap(unlink$1, true, 2);\nconst updateCurrentUser = _zoneWrap(updateCurrentUser$1, true, 2);\nconst updateEmail = _zoneWrap(updateEmail$1, true, 2);\nconst updatePassword = _zoneWrap(updatePassword$1, true, 2);\nconst updatePhoneNumber = _zoneWrap(updatePhoneNumber$1, true, 2);\nconst updateProfile = _zoneWrap(updateProfile$1, true, 2);\nconst useDeviceLanguage = _zoneWrap(useDeviceLanguage$1, true, 2);\nconst validatePassword = _zoneWrap(validatePassword$1, true, 2);\nconst verifyBeforeUpdateEmail = _zoneWrap(verifyBeforeUpdateEmail$1, true, 2);\nconst verifyPasswordResetCode = _zoneWrap(verifyPasswordResetCode$1, true, 2);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Auth, AuthInstances, AuthModule, applyActionCode, authInstance$, authState, beforeAuthStateChanged, checkActionCode, confirmPasswordReset, connectAuthEmulator, createUserWithEmailAndPassword, deleteUser, fetchSignInMethodsForEmail, getAdditionalUserInfo, getAuth, getIdToken, getIdTokenResult, getMultiFactorResolver, getRedirectResult, idToken, initializeAuth, initializeRecaptchaConfig, isSignInWithEmailLink, linkWithCredential, linkWithPhoneNumber, linkWithPopup, linkWithRedirect, onAuthStateChanged, onIdTokenChanged, parseActionCodeURL, provideAuth, reauthenticateWithCredential, reauthenticateWithPhoneNumber, reauthenticateWithPopup, reauthenticateWithRedirect, reload, revokeAccessToken, sendEmailVerification, sendPasswordResetEmail, sendSignInLinkToEmail, setPersistence, signInAnonymously, signInWithCredential, signInWithCustomToken, signInWithEmailAndPassword, signInWithEmailLink, signInWithPhoneNumber, signInWithPopup, signInWithRedirect, signOut, unlink, updateCurrentUser, updateEmail, updatePassword, updatePhoneNumber, updateProfile, useDeviceLanguage, user, validatePassword, verifyBeforeUpdateEmail, verifyPasswordResetCode };\n"],
  "mappings": "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",
  "names": ["getLimitedUseToken", "getToken", "initializeAppCheck", "onTokenChanged", "setTokenAutoRefreshEnabled", "user", "authState", "idToken", "user", "applyActionCode", "beforeAuthStateChanged", "checkActionCode", "confirmPasswordReset", "connectAuthEmulator", "createUserWithEmailAndPassword", "deleteUser", "fetchSignInMethodsForEmail", "getAdditionalUserInfo", "getAuth", "getIdToken", "getIdTokenResult", "getMultiFactorResolver", "getRedirectResult", "initializeAuth", "initializeRecaptchaConfig", "isSignInWithEmailLink", "linkWithCredential", "linkWithPhoneNumber", "linkWithPopup", "linkWithRedirect", "onAuthStateChanged", "onIdTokenChanged", "parseActionCodeURL", "reauthenticateWithCredential", "reauthenticateWithPhoneNumber", "reauthenticateWithPopup", "reauthenticateWithRedirect", "reload", "revokeAccessToken", "sendEmailVerification", "sendPasswordResetEmail", "sendSignInLinkToEmail", "setPersistence", "signInAnonymously", "signInWithCredential", "signInWithCustomToken", "signInWithEmailAndPassword", "signInWithEmailLink", "signInWithPhoneNumber", "signInWithPopup", "signInWithRedirect", "signOut", "unlink", "updateCurrentUser", "updateEmail", "updatePassword", "updatePhoneNumber", "updateProfile", "useDeviceLanguage", "validatePassword", "verifyBeforeUpdateEmail", "verifyPasswordResetCode"]
}
